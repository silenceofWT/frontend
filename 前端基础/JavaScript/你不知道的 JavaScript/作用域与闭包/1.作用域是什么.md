# 1.作用域是什么
作用域本质上是一套存储变量的规则。
## 1.1 理解作用域
我们假设要解析以下代码：
```
var a = 1
```
参与的角色有：
- JS 引擎：负责整个程序的编译执行。
- 编译器：负责语法分析和代码生成等。
- 作用域：收集和维护变量并提供一套严格的查询规则。

**协作流程**

编译器遇到 var a 时，会询问作用域中是否已经有 a 的声明了，有就忽略，否则就会声明一个叫 a 的变量；

接下来编译器会为引擎生成代码，用来处理 a = 2 赋值操作。引擎在运行时会询问当前作用域中是否存在一个叫 a 的变量，没有就会向上层去查找，如果最终找到 a，会将 2 赋值给它，否则引擎会抛出一个异常。

**查找类型**

查找类型分为两种 LHS（查找赋值的容器） 和 RHS（获取某个值），比如 a = b，对于赋值操作，a 会进行 LHS 查询，b 会进行 RHS 查询。

- 示例1
```
console.log(a)
```
上面代码的 a 的查找为 RHS，只是需要查找并取得 a 的值。

- 示例 2
```
a = 2
```
上面代码的 a 则是 LHS 查询，我们不关心赋值符号右边是什么值，只是为了给赋值操作找一个目标容器来装它。也就是找到名字为 a 的容器来装 2 这个值。

- 示例3
```
function foo(a){
  console.log(a) // 2
}
foo(2)
```

上面代码既有 LHS 也有 RHS；
首先函数传参会将 2 传递给参数 a，为 LHS；
而打印 a 的过程则是通过 RHS 查找 a 的值。

## 1.2 作用域嵌套
```
function foo(a){
  console.log(a + b)
}
var b = 2
foo(2)
```

在 foo 函数执行时，会从 foo 函数作用域中进行 b 的 RHS 查找，由于没有找到，会往上一层作用域查找，在全局作用域中找到该变量，查找结束。

## 1.3 异常
上面我们为什么要区分 LHS 和 RHS 呢？
```
// 实例1
function foo(a){
  console.log(a + b) // 引用错误
}
foo(2)
// 实例2
function foo(a){
  b = a;// window.b 为 2
}
foo(2)
```

当对 b 进行 RHS 查询时，如果直到全局作用域中还没有找到，那么会抛出引用异常（ReferenceError）；而在非严格模式下，进行 LHS 时，如果在全局作用域下未找到该声明，那么全局作用域中就会自动创建一个该变量。